# Cecile Pereira
# cecilepereira@ufl.edu
# 02/07/2017
# Rscript Classifier_fromSqanti_V2.R -p totest/TP.txt -n totest/TN.txt -c all.good.5merge.collapsed.longest_rep_classification.txt -o Test_classout
# last modification: do not apply the classifier to monoexonic transcripts

rm(list=ls())

# NEEDS:
# package optparse 
# package caret
# package ggplot2
# package lattice
# package foreach
# package e1071
# package randomForest
# package rpart

list.of.packages <- c("rpart", "ROCR", "caret", "optparse", "ggplot2", "lattice", "foreach", "e1071","randomForest","rpart", "doMC")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages,repos = "https://cloud.r-project.org/")

library(rpart)           #Rpart package
library(ROCR)            #ROC curve
library(caret)           #confusion matrix
library("optparse")
library(doMC)

# INPUTS: 
# TP set (PacbioID, first column of sqanti files)
# TN set (PacbioID, first column of sqanti files)
# Sqanti classification file


#definition of the inputs
option_list=list(
  make_option(c("-p","--TP"), type="character",default = NULL,help="file containing the list of the TP transcripts, one ID by line, no header"),
  make_option(c("-n","--TN"), type="character",default = NULL,help="file containing the list of the TN transcripts, one ID by line, no header"),
  make_option(c("-c","--sqanti_classif"),type="character",default = NULL,help="Sqanti classification output file"),
  make_option(c("-o","--out"),type="character", default="Classifier_out",help="Output repository name")
  #,make_option(c("-s","--selection"),type="integer",default=0,help="Recompute the feature selection (1 yes, 0 no), default 0")
)

#options(warn=-1)
opt_parser=OptionParser(option_list = option_list)
opt=parse_args(opt_parser) #list of the args
registerDoMC(cores=2)

if(is.null(opt$TP)|is.null(opt$TN)|is.null(opt$sqanti_classif)){
  print_help(opt_parser)
  stop("At least one argument must be supplied")
}


###############################
# functions
###############################

# classifier: 
# Generate the classifier
# TP: dataframe with one colomn containing the list of the TP transcripts
# TN: dataframe with one colomn containing the list of the TN transcripts
# training: dataframe with one column by feature and the TP and TN as rows (ordered TP then TN)
# out: repository with the output files generated by the classifier function
classifier<-function(TP,TN,training,out){
  Class=factor(c(rep("True_POSITIVE",length(TP$V1)),rep("True_NEGATIVE",length(TN$V1))),
               levels=c('True_POSITIVE','True_NEGATIVE'),
               labels=c('Pred_POS','Pred_NEG'))
  
  ctrl=trainControl(method="repeatedcv",repeats=10,
                    classProbs = TRUE,
                    summaryFunction = twoClassSummary,
                    sampling='down',returnData=TRUE,
                    savePredictions = TRUE, returnResamp='all')
  set.seed(1)
  ##########################################
  #classifier
  #randomforestdfs <- train(Class ~ colnames(training), data = training,
  randomforestdfs <- train(training,Class,
                           method ='parRF',
                           tuneLength=4,
                           metric = "ROC",
                           trControl = ctrl)
  ##########################################
  #confusion matrix on the training set
  #
  info="rows:predictions \ncolumns:reference"
  #columns=reference
  cm=confusionMatrix(randomforestdfs)
  write(cm$text,file=paste(out,"/confusion_matrix_trainingset.txt",sep=''))
  write(paste(info,"\n"),file=paste(out,"/confusion_matrix_trainingset.txt",sep=''),append = TRUE)
  write.table(cm$table,file=paste(out,"/confusion_matrix_trainingset.txt",sep=''),append=TRUE)
  
  ##########################################
  #feature importance
  imp=varImp(randomforestdfs)
  write.table(imp$importance,file=paste(out,"/Variable_Importance_trainingset.txt",sep=''))
  
  ##########################################
  #analysis area under roc: ROC CURVES
  pdf(paste(out,'/ROC_curves_RF.pdf',sep=''))
  predtable=randomforestdfs$pred
  predtable=predtable[predtable$mtry==as.numeric(randomforestdfs$bestTune),]#randomforestdfs$bestTune value of the selected mty
  p=prediction(predtable$Pred_POS,predtable$obs)
  perf=performance(p,'tpr','fpr')
  plot(perf,col='red',main='ROC curves',lwd=1.5)
  auc=performance(p,"auc")
  totauc=c()
  for(i in 1:10){
    if(i<10){
      i=paste('0',i,sep='')
    }
    sample=grep(paste('Rep',i,sep=''),predtable$Resample)
    p=prediction(predtable[sample,]$Pred_POS,predtable[sample,]$obs)
    perf=performance(p,'tpr','fpr')
    #print(perf)
    auc=performance(p,"auc")
    #print(auc)
    auc=unlist(slot(auc,"y.values"))
    #print(auc)
    totauc=c(totauc,auc)
    lines(unlist(slot(perf,'x.values')),unlist(slot(perf,'y.values')),col='black',lty=2)
  }
  text(0.8,0.2,labels=paste("aur=",round(auc,2)))
  dev.off()
  
  #######################
  #return the classifier object
  return(randomforestdfs)
}

# feature boxplot
# boxplot of the features, groups in function of the prediction positive or negative
# rep: output repository
# file: output file name
# data: dataframe with the columns of interrest
# predit: predictions values foreach rows of data
featPlot<-function(rep=opt$out,file="feature_importance.pdf",data,predit){
  pdf(paste(rep,"/",file,sep=''),width=20,height=10)
  dfs5b=data
  dfs5b$bite=data$bite+1
  dfs5b$Min_sample_cov=data$Min_sample_cov+1
  dfs5b$MinCov=data$MinCov+1
  dfs5b$isoExp=data$isoExp+1
  
  Class_pn=factor(predit,levels=c('Pred_POS','Pred_NEG'),labels=c('Positive','Negative'))

  par(mfrow=c(2,3))
  dfs=SC[,c("MinCov","Min_sample_cov","bite","FL","isoExp")]
  color=c('green','orange')
  boxplot(dfs5b$MinCov~Class_pn,log='y',main="Minimum coverage",ylab='log scale',col=color)
  boxplot(dfs5b$Min_sample_cov~Class_pn,log='y',main="Minimum sample coverage",col=color)
  boxplot(dfs5b$bite~Class_pn,log='y',main="BITE",col=color)
  boxplot(dfs5b$FL~Class_pn,log='y',main="#Full length",col=color)
  boxplot(dfs5b$isoExp~Class_pn,log='y',main="Transcript exp",col=color)
  dev.off()
}

######################################
# Main
######################################

## Access to the input files
SC=read.table(opt$sqanti_classif,header = TRUE)
TP=read.table(opt$TP,header=FALSE,as.is = TRUE)
TN=read.table(opt$TN,header=FALSE,as.is=TRUE)

rownames(SC)=SC$isoform

################################
# List of the selected features:
###############################
# position of the min coverage
# BITE
# Cov last exon
# Transcript expression
# Exon min cov
# Min sample cov
# Min cov
# FL number
 
#######################################
# removing the monoexonic transcripts

SCmono=SC[SC$exons==1,]#info of the monoexons
print("WARNING: No evaluation of the monoexon")
print(paste("Number of monoexons: ",dim(SCmono)[1]))
SC=SC[!SC$exons==1,]#all the others
print(paste("Number of transcripts evaluated: ",dim(SC)[1]))

###############################
# data pretreatment
# pretreatment of the data for the 8 variables preselected: Removing NA
for(i in 1:length(SC$MinCov)){
  if(is.na(SC$MinCov[i])){#0 gene expression, 0 transcript expression
    SC$MinCov[i]=0
    print(paste("WARNING: ",SC$isoform[i], "NA value for the parameter minimum coverage, default value=0"))
  }
  if(is.na(SC$Min_sample_cov[i])){
    SC$Min_sample_cov[i]=0
    print(paste("WARNING: ",SC$isoform[i], "NA value for the parameter Minimum sample coverage, default value=0"))
  }
  if(is.na(SC$bite[i])){#default value for bite=FALSE
    SC$bite[i]=FALSE
    print(paste("WARNING: ",SC$isoform[i], "NA value for the parameter bite, default value=FALSE"))
  }

  if(is.na(SC$FL[i])){#default value for FL = 1
    SC$FL[i]=1
    print(paste("WARNING: ",SC$isoform[i], "NA value for the parameter FL number, default value=1"))
  }
  if(is.na(SC$isoExp[i])){
    SC$isoExp[i]=0
    print(paste("WARNING: ",SC$isoform[i], "NA value for the parameter isoform expression, default value=0"))
  }
}


###########################
# Filter of the features: selection of the interresting 5 features (no features with exon coverage)
dfs=SC[,c("MinCov","Min_sample_cov","bite","FL","isoExp")]
training=dfs[c(TP$V1,TN$V1),]

###########################
# classifier with the 5 features (no info intron coverage) and the input training set
classif=classifier(TP,TN,training,opt$out)

###########################
# prediction on the rest of the set
predit=predict(classif,dfs)
restot=cbind(SC,predit)
tmp=cbind(SCmono,rep("Pred_POS",length(SCmono[,1])))
colnames(tmp)=colnames(restot)
restot=rbind(restot,tmp)#add positive prediction for all the monoexonic transcripts


#write.table(restot,file=paste(opt$out,'/predict_completetable.txt',sep=''),sep='\t',row.names = FALSE, quote=F)
subt=restot[rownames(training),]
#table(c(rep("TP",length(TP$V1)),rep("TN",length(TN$V1))),subt$predit)


restot[restot$structuralCategory %in% c("full-splice_match", "incomplete-splice_match"), "predit"] <- "Pred_POS"

curatedTransc = rownames(restot[restot$predit=="Pred_POS",])
write.table(curatedTransc,file=paste(opt$out,'/curated_transcriptome.txt',sep=''),sep='\t',col.names = FALSE, row.names = FALSE, quote=F)


featPlot(rep=opt$out,file="feature_importance_total.pdf",data=dfs,predit=predit)
featPlot(rep=opt$out,file="feature_importance_training.pdf",data=training,predit=c(rep("Pred_POS",length(TP$V1)),rep("Pred_NEG",length(TN$V1))))

